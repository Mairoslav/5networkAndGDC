//: [Previous](@previous)
//: ### Handle Errors
//: The errors referred to by "error handling" are not like warnings or issues raised by Xcode and the compiler. They are also not [software bugs](https://en.wikipedia.org/wiki/Software_bug). Instead, these errors are either intentionally caused or generated in situations where correct behavior cannot be fully guaranteed.
//:

//: To review...
//: - a compile-time error (or warning) can be generated by the compiler, before code is run
//: - a run-time error (sometimes called a logic error) is caused by code that is syntactically correct, but logically incorrect or causes a crash when code is running
//:
//: _These kinds of errors can be fixed._
//:
func addTwoNumbers(num1: Int, num2: Int) -> Int {
    // (uncomment) generates a compile-time warning
    // let number = 4
    
    // (uncomment) generates a compile-time error
    //let x: Int = "string"
    
    // a logic error, this function should add two numbers (not subtract!)
    return num1 - num2
}

addTwoNumbers(num1: 4, num2: 6)
//: The errors in "error handling" can happen even when code is syntactically correct. Consider Apple's `String` initializer that accepts a `URL` (a path to a file) and attempts to read its contents into a string:
//:
//: **```init(contentsOf url: URL, encoding enc: String.Encoding) throws```**
//:
//: It is possible that the contents of the URL cannot be read into a string because the file isn't a text file — even if it is named like one. Or perhaps the URL (path) refers to a location that doesn't exist. This doesn't make the initializer invalid, but it does mean that it is prone to, and could generate, an error. Hence, the `throw` keyword. `throw` informs a developer that a function (or initializer) can generate an error and that it must be called according to Swift's error handling rules.
//:

//: To call a function that throws errors, a `do`-`catch` statement may be used. The `do`-`catch` statement is composed of two blocks: `do` and `catch`. The `do` block safely executes error-prone code, but it requires all error-prone calls to use the `try` keyword. If an error is thrown by any function in the `do` block, then the `catch` block is executed.
import Foundation

print("CORRECT_1:")

// read the contents of a text file into a string; should run without error
if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "txt") {
    // run error-prone code
    do {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        print(content)
    } catch {
        print("ERROR: oh no! there was a problem")
    }
}

print("ERROR_1:")

// read the contents of an image file into a string; should generate error because of "png" extension instead of "txt" one.

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // run error-prone code
    do {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        print(content)
    } catch {
        print("ERROR: oh no! there was a problem 1")
    }
}

print("ERROR_2:")

//: When a catch block is executed, it automatically defines a constant called "error". This constant is of type `Error` and it has a localized description property with helpful information about the cause of the problem.

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    do {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        print(content)
    } catch {
        print("ERROR_2.0:")
        print(error) // notice, error is implicitly defined
        print("ERROR_2.1:")
        print(error.localizedDescription) // see appleDocumentation, .localizedDescription gives us conscise information with the rest of extra information removed
    }
}

print("ERROR_3:")

//: For readability, the "error" constant can be explicitly defined using `catch let error`.

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    do {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        print(content)
    } catch let error { // error is defined explicitly, note catch let error
        print(error) // error is defined explicitly and available for use in the catch block
    }
}

print("ERROR_4:")

//: - Callout(Watch Out!):
//: Multiple error-prone functions or initializers may be called within a `do` block. But, this makes identifying the cause of the error more difficult. Therefore it is recommended to have single statement within do block.
//:
if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "txt") {
    // create urls that don't exist
    let directoryWithFileURL = fileURL.deletingLastPathComponent()
    let badURL1 = directoryWithFileURL.appendingPathComponent("unknown-file-1")
    let badURL2 = directoryWithFileURL.appendingPathComponent("unknown-file-2")
    
    do {
        var content = ""
        
        content = try String(contentsOf: badURL1, encoding: .utf8)
        print(content)
        
        content = try String(contentsOf: badURL2, encoding: .utf8)
        print(content)
    } catch {
        print("it will take more information to determine the cause of error...")
    }
}
//: 3. Types of Errors, 0:57: In the examples above, `catch` handles any error thrown in the `do` block; some languages refer to this as a "catch all". However, in many cases, it's helpful to catch specific errors and handle them uniquely. Below, specific errors are caught and handled based on an error code. An error code is an integer which can be used to help identify a specific error. Otherwise you are loosing the ability which try is actually throwing/causing the error.
//: 2:39: https://developer.apple.com/documentation/foundation/cocoaerror
//: 2:50: https://developer.apple.com/documentation/foundation/cocoaerror/2506638-filereadinapplicablestringencodi
//: 3:05: great resource for pinpointing error faster compared to pinpointing them via appleDocumentation(here have to dig deep) is: https://www.osstatus.com, from this main page search using the error code, that was printed in the playground. If you recall it was 261. Even though there it is written bit differently as per ObjectiveC, it is OK, can get us close enough to what we are looking for.

print("ERROR_4.1:") // 3:47 CocoaError.fileReadInapplicableStringEncoding

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    do {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        print(content)
    // when withExtension: "png" it prints error below. When "txt" it prints constant content
    } catch CocoaError.fileReadInapplicableStringEncoding {
        print("cannot read file into a String, because of png instead of txt withExtension")
    } catch {
        print(error)
    }
}

print("ERROR_5:")

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // create a url that does not exist
    // 3:55 we use invalid URL, that points to essentialy nothing
    let erroneousURL = fileURL.appendingPathComponent("unknown-path")
    
    do {
        let content = try String(contentsOf: erroneousURL, encoding: .utf8)
        print(content)
    } catch CocoaError.fileReadInapplicableStringEncoding {
        print("cannot read file into a string")
    // below CocoaError.fileReadUnknown we add after running the code and see error code 256 in debug console area. We insert 256 code in OSStatus.com and it tells us that error name is NSFileReadUnknownError, we search something close to it in apple developer documentation and see it is fileReadUnknown, so we create new catch block as you can see below.
    // even though now the error code 256 is now not printed in debug console, it is all right, because we get it by well descriptive name of error .fileReadUnknown
    } catch CocoaError.fileReadUnknown {
        print("file unknown, cannot read")
    // last catch block is general one, in case none of above catch block does address the error. So that is is catched here.
    } catch {
        print("\(error)")
    }
}
//: - Callout(Watch Out!):
//: If you catch an error by specifying an error code, then the "error" constant is not avaiable. Don't worry, if the error code is known, then the "error" constant is probably not needed.

print("ERROR_6:")

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // create a url that does not exist
    let erroneousURL = fileURL.appendingPathComponent("unknown-path")
    
    do {
        let content = try String(contentsOf: erroneousURL, encoding: .utf8)
        print(content)
    } catch CocoaError.fileReadInapplicableStringEncoding {
        // uncomment the print statement to see Xcode complain
        // print("\(error)") /* the error constant does not exist */
        print("cannot read file into a string")
    } catch CocoaError.fileReadUnknown { // this catch block is executed
        print("file unknown, cannot read")
    } catch {
        print("\(error)")
    }
}

//: Alternatively, errors can be caught by type using the `catch is` syntax. As seen before, all errors implement the `Error` protocol. Additionally, all errors extend from `NSError` which provides more information for troubleshooting like a string property called "domain" that classifies the origin of an error. An error's domain may also suggest if the error can be casted into a more specific type like `CocoaError`, `POSIXError`, or `MachError`. See [Apple's documentation on error objects, domains, and codes](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html) to learn more.

print("ERROR_7:")

// 5:28 there are few other ways to write catch blocks, here we go quickly - for going more deep check the links alongside the video
// first you can catch an error by checking its type using one of the more specific error types like CocoaError, PosixError or MachError. *** And the syntax differs little bit, you have to say catch is, and then the error type that you are checking for.

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // create a url that does not exist
    let erroneousURL = fileURL.appendingPathComponent("unknown-path")
    
    do {
        let content = try String(contentsOf: erroneousURL, encoding: .utf8)
        print(content)
    // *** and the syntax differs little bit, you have to say catch is, and then the error type that you are checking for
    } catch is CocoaError {
        print("this error is a CocoaError")
    } catch {
        print("\(error)")
    }
}
//: - Callout(Watch Out!):
//: It is redundant to check if an error is a `NSError`, and it will cause a compiler warning. Remember, all errors extend from `NSError`.

print("ERROR_8:")

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // create a url that does not exist
    let erroneousURL = fileURL.appendingPathComponent("unknown-path")
    
    do {
        let content = try String(contentsOf: erroneousURL, encoding: .utf8)
        print(content)
    }
    // un/comment the section below to see Xcode warn about catching an error as `NSError`
    /*
    catch is NSError { // warning: "'is' test is always true" when NSError. Not case with CocoaError
        print("this error is an NSError")
    }
    */
    catch {
        print("\(error)")
    }
}
//: 5:48 To catch and cast an error by type, combine `catch let error` with a type cast. In the example below, an error is casted into `CocoaError` which exposes common error codes generated by core Apple frameworks.

print("ERROR_9:")

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // create a url that does not exist
    let erroneousURL = fileURL.appendingPathComponent("unknown-path")
    
    do {
        let content = try String(contentsOf: erroneousURL, encoding: .utf8)
        print(content)
    } catch let error as CocoaError { // handle if error can be casted into a `CocoaError`. So here we have caught a CocoaError and we have casted it into this error constant 5:51
        // then we are switching over its error code, which is a property of a CocoaError. And we can do really whatever we want here. This works well for the more specific error types.
        switch error.errorCode {
        case CocoaError.fileReadInapplicableStringEncoding.rawValue:
            print("cannot read file into a string")
        case CocoaError.fileReadUnknown.rawValue:
            let errorCode = CocoaError.fileReadUnknown.rawValue
            print("file unknown, cannot read, errorCode: \(errorCode) - fileReadUnknown") // this is printed out
        default:
            print("cocoa error with code: \(error.errorCode)")
        }
    } catch {
        print("\(error)")
    }
}

print("ERROR_10:")

//: Because Swift functions cannot expliclty specify the errors they throw, it can be difficult, or near impossible, to predict the types of errors to catch. In these cases, try casting the error to an `NSError` and print its error code, domain, and any additional information that may be helpful. If the error is generated by an Apple API, then try using a service like [OSStatus.com](https://www.osstatus.com) or Google, to find more information about the error.

if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
    // create a url that does not exist
    let erroneousURL = fileURL.appendingPathComponent("unknown-path")
    
    do {
        let content = try String(contentsOf: erroneousURL, encoding: .utf8)
        print(content)
    //: 6:07 Then finally we have the casting into NSError. Remember all errors can be automatically casted into an NSError, and this gives us access to the error's description, domain, code, and any other information stored in the user info dictionary.
    } catch let error as NSError { /* handle if error can be casted into an `NSError` */
        print("error description: \(error.localizedDescription)")
        print("error domain: \(error.domain)")
        print("error code: \(error.code)")
        print("error user info: \(error.userInfo)")        
    } catch {
        print("\(error)")
    }
}

/*
 MARK: HandleErrors - QUIZ QUESTION
 Use Apple’s documentation to determine which of the following functions throws an error. Click the name of each function to open the documentation.
 */

// 1. MARK: Data / init(contentsOf: Options:)
    // Try again: In Apple’s documentation, start by searching for the class and then for the function.
// 2. MARK: UIView / updateConstraints()
    // Try again: In Apple’s documentation, start by searching for the class and then for the function.
// 3. MARK: AVAudioEngine / start()
    // Try again: In Apple’s documentation, start by searching for the class and then for the function.
// 4. MARK: UINavigationController / popViewController(animated:)
    // Try again: In Apple’s documentation, start by searching for the class and then for the function.

// MARK: Solution is, options 1. and 3. are correct

/*
 additional links alongside the video:
 https://osstatus.com
 
 https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorObjectsDomains/ErrorObjectsDomains.html
 
 https://developer.apple.com/documentation/swift/error
 
 https://developer.apple.com/documentation/foundation/nserror
 
 https://developer.apple.com/documentation/foundation/cocoaerror
 */
//: [Next](@next)
