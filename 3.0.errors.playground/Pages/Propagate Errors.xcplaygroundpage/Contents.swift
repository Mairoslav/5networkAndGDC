//: [Previous](@previous)
//: ### Propagate Errors
//: When errors are thrown by a function, they must be handled immediately or passed (propagated) to the code that called the function. In the example below, the `readFileIntoString` function calls the error-prone string initializer. If any error occurs, it is handled immediately.
//: 0:00 Thus far, you have seen, how to catch an error when it is thrown. But how do you actually throw an error?
import Foundation

print("CASE_1:")

func readFileIntoString(fileName: String, fileExtension: String) {
    // if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "txt") {
    if let fileURL = Bundle.main.url(forResource: fileName, withExtension: fileExtension) {
        do {
            let content = try String(contentsOf: fileURL, encoding: .utf8)
            print(content)
        } catch {
            print("error handled immediately!") // this prited out when swift.png, has to be .txt
        }
    }
}

// readFileIntoString(fileName: "swift", fileExtension: "txt") // prints swift.file
readFileIntoString(fileName: "swift", fileExtension: "png") // prints error


print("CASE_2:")

//: To propagate all possible errors to the calling site, start by removing the `do`-`catch` statement and adding `throws` to the signature of the function which calls the error-prone code.
//:
func readFileIntoStringWithThrows(fileName: String, fileExtension: String) throws {
    if let fileURL = Bundle.main.url(forResource: fileName, withExtension: fileExtension) {
        let content = try String(contentsOf: fileURL, encoding: .utf8)
        print(content)
    }
}
//: Now, any code that calls `readFileIntoStringWithThrows` is responsible for handling any errors it generates.
//: MARK: note that "do-catch" blocks are out of declaration of func `readFileIntoStringWithThrows`, instead are there when calling this function:
do {
    try readFileIntoStringWithThrows(fileName: "swift", fileExtension: "png") // "txt"
} catch {
    print("the error was propagated to me, and I handled it!")
}

print("CASE_3:")

//: - Callout(Watch Out!):
//: If an error can be generated by a function, but it is never handled, then Xcode will complain.
//:
func callErrorProneCode() {
    // uncomment this function call to see Xcode complain about an unhandled error: "Errors thrown from here are not handled" because no "do-catch" block
    // try readFileIntoStringWithThrows(fileName: "swift", fileExtension: "png")
}

print("CASE_4:")

//: 1:42 Sometimes it is appropriate to handle some errors immediately while propagating others for further processing. To propagate a specific error, use the `throw` keyword.
//:
func readFileIntoStringHandleAndThrow(fileName: String, fileExtension: String) throws {
    if let fileURL = Bundle.main.url(forResource: fileName, withExtension: fileExtension) {
        do {
            let content = try String(contentsOf: fileURL, encoding: .utf8)
            print(content)
        } catch CocoaError.fileReadUnknown { // handle only .fileReadUnknown error
            print("file unknown, cannot read")
        } catch let error { // 1:53 then in the catch all block
            throw error /* throw (propagate) any error that might reach this block, to the call site */
        }
    }
}

do {
    try readFileIntoStringHandleAndThrow(fileName: "swift", fileExtension: "png")
} catch let error {
    print("handling error: \(error.localizedDescription)")
}
 
//: - Callout(Watch Out!):
//: In a playground, if an error is generated and not handled in the global scope, then the playground's execution will stop.
//:
/* MARK: uncomment this line and the playground will stop executing because the error is not handled: "Playground execution terminated: An error was thrown and was not caught:
Error Domain=NSCocoaErrorDomain Code=261 "The file “swift.png” couldn’t be opened using text encoding Unicode (UTF-8)." UserInfo={NSFilePath=/var/folders/06/wxj3t2k973l39zmcq4p0bfgm0000gn/T/com.apple.dt.Xcode.pg/resources/91E577F7-3785-49B1-8BA3-7D8714AC6A8E/swift.png, NSStringEncoding=4} */
// try readFileIntoStringHandleAndThrow(fileName: "swift", fileExtension: "png")

// if the error is not handled, then this print statement is never reached
print("print me whoo hoo!")

print("CASE_5:")

/*
 2:01 Or it is even possible to catch an error and then throw a different error. Here we have created our custom NSError with the domain ErrorTesting. And you can customize this to your heart's desire.
 */

func printFileContents() throws {
    if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") {
        do {
            let constant = try String(contentsOf: fileURL, encoding: .utf8)
            print(constant)
        } catch CocoaError.fileReadUnknown {
            print("file is unknown, cannot read it")
        } catch {
            throw NSError(domain: "ErrorTesting", code: 777, userInfo: ["FAILURE" : "Something went wrong"])
        }
    }
}

// printFileContents() // Call can throw but is not marked with 'try'

do {
    try printFileContents()
} catch {
    print("whopp: \(CocoaError.fileReadUnknown)")
    print("lalala: \(error)")
    print("posrala: \(error.localizedDescription)")
}

print("quizQuestion_1:")

// MARK: Quiz-PropagateErrors_Q1:
// For the first question, consider the following code snippet:

func printDataAtURL(url: URL) {
    // if let url = Bundle.main.url(forResource: "swift", withExtension: "txt") {
        do {
        let data = try Data(contentsOf: url) // *** errors thrown from here are not handled because the enclosing catch is not exhaustive
            print("\(data)")
        } catch CocoaError.fileReadNoSuchFile {
            print("nothing exists at url")
        } catch { // *** this last catch block was missing, can see when commented out
            print(error)
        }
    }
// } // when uncomment, can see printed out: 14 bytes

let urlX = URL(fileURLWithPath: "dummy-path")
// let urlX = URL(fileURLWithPath: "/Users/mairo/Documents/10 Udacity/5networkAndGDC/3.0.errors.playground/Pages/Handle Errors.xcplaygroundpage/Resources/swift.txt")
printDataAtURL(url: urlX)

// Will Xcode generate a compile-time error or warning for the above code?
    // a) Xcode will generage an error or warning
    // b) Xcode will not generage an error or warning

// a) is correct. Yes, Good job. The *** error handling in the do-catch statement isn't exhaustive so this code will not compile.

print("quizQuestion_2:")

// MARK: Quiz-PropagateErrors_Q2:
// For the second question, consider the following code snippet:

func printDataInfoAtURL(url: URL) {
    do {
        let data = try Data(contentsOf: url) // *** Errors thrown from here are not handled because the enclosing catch is not exhaustive
        print("\(data)")
    } catch is CocoaError {
        print("a cocoa error was caught")
    } catch is POSIXError {
        print("a posix error was caught")
    } catch is MachError {
        print("a mach error was caught")
    } catch { // *** this last catch block was missing, can see when commented out
        print(error)
    }
}

let urlPath = URL(fileURLWithPath: "dummy-path")
printDataInfoAtURL(url: urlPath)

// Will Xcode generate a compile-time error or warning for the above code?
    // a) Xcode will generage an error or warning
    // b) Xcode will not generage an error or warning

// a) is correct. Correct. The error handling in the do-catch block is extensive, but not exhaustive. To avoid this problem, you can use a "catch all" block.

/*
 How to Copy a File Path as Text from Mac Finder in Mac OS X:
    https://osxdaily.com/2015/11/05/copy-file-path-name-text-mac-os-x-finder/
 */

//: [Next](@next)
